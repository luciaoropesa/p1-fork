Aquí voy a ir dejando los comentarios sobre cada comando usado en la práctica.
Los comandos a usar son los siguentes: 
git clone
git status
git add
git commit
git push
git checkout


Primero, tuve que copiarme el repositorio del fork dado en mi cuenta de github. Una vez hecho esto, creo el .txt para poder ir 
comentando el resto de procedimientos. 

1. git clone https://github.com/gitt-3-pat/p1   ------> más abajo (línea 121) explico el fallo al haber usado esta dirección 
------------- Impreso en la terminal: 
Cloning into 'p1'...
remote: Enumerating objects: 6, done.
remote: Counting objects: 100% (1/1), done.
remote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 5 (from 1)
Receiving objects: 100% (6/6), done.
------------------

Sirve para descargar el repositorio de la nube (GitHub()) al ordenador local desde el que estoy trabajando. Ahora, en la carpeta p1 
puedo encontrar el mismo archivo README.md. Si hubiera más archivos, también los encontraría dentro de la carpeta 'p1'.  

2. git status 
Para ello, ejecuto 'cd p1' para poder trabajar dentro de la carpeta y que los comandos funcionen. 
-------Impreso en la terminal: 
On branch main
Your branch is up to date with 'origin/main'.
nothing to commit, working tree clean
---------
Esto quiere decir que estamos en la rama principal y que no hay cambios en ella. Es decir, que todo está sincronizado y guardado.
Para ver que este comando funcione, vamos a crear un .txt dentro de la carpeta y veremos si cambia algo. 

----Impreso en la terminal (después de crear y escribir en el .txt)
On branch main
Your branch is up to date with 'origin/main'.
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        prueba.txt
nothing added to commit but untracked files present (use "git add" to track)
------------
Aquí vemos la diferencia. Nos devuelve un "tienes este nuevo archivo creado y editado, pero no lo reconozco ya que no está añadido.
En el caso de querer guardarlo, haz uso de "git add" "). 

3. git add prueba.txt
Para que reconozca el archivo, debo añadirlo. 
Aquí no devuelve nada por pantalla, pero si vuelvo a ejecutar "git status", obtengo lo siguiente: 
------------Impreso por pantalla: 
On branch main
Your branch is up to date with 'origin/main'.
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   prueba.txt
------------------------
Por tanto, ahora ya tengo el archivo guardado y reconocido. 

Ahora, si vuelvo a editarlo y ejecuto "git status", me aparece lo siguiente: 
---Impreso por pantalla: 
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   prueba.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   prueba.txt
----------------
Lo que quiere decir que al haber editado el archivo, los cambios no se han guardado. Para que se guarden, puedo hacer uso de "git add". 
Para comprobar que l modifiación de ha guardado, vuelvo a hacer uso de git status
-----Impreso por pantalla: 
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   prueba.txt
---------------
Como puedo ver, los cambios se han guardado en el archivo. 

Si volviera a editarlo, tendría que seguir el mismo procedimiento (usar "git add" para guardar cambios y "git status" para comprobarlo).

4. git commit -m "añadiendo git.txt con la documentación de la práctica"
Para ello, primero debo añadir el git.txt a la carpeta "p1" siguiendo el procedimiento anterior. 
----Impreso por pantalla: 
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   git.txt
        new file:   prueba.txt
---------
Una vez tengo el git.txt, aplico el commit. 
Obtengo lo siguiente: 
----Impreso por pantalla: 
[main deb467f] añadiendo git.txt con la documentación de la práctica
 2 files changed, 100 insertions(+)
 create mode 100644 git.txt
 create mode 100644 prueba.txt
 -----------------

Esto quiere decir que tiene 2 archivos (prueba.txt y git.txt) guardados en la historia nuestro ordenador local. 
¿Pero antes no estaban guardados?
Realmente sí, pero la forma de trabajar con ctrl+s (guardar normal un bloc de notas) y un commit es diferente: 
  - Guardando normal -> si borro información y guardo, jamás podré volver a recuperarla. Es similar a decir que sólo trabaja a tiempo presente.
  - Usando commit -> haga lo haga, todo queda registrado y puedo volver a acceder a ello. Lo malo es que tengo que repetir todo el proceso anterior
                    si realizo algún cambio nuevo ya que no guarda cambios futuros (digamos que no trabaja de manera "online"). 

5. git push origin main
Con este comando lo que hago es enviarle toda la información a la nube. 
Al ejecutar el comando desde la rama main (es donde estoy), obtengo lo siguente. 
------Impreso en la terminal: 
remote: Permission to gitt-3-pat/p1.git denied to luciaoropesa.
fatal: unable to access 'https://github.com/gitt-3-pat/p1/': The requested URL returned error: 403
--------
Me da error porque estoy tratando de subir los cambios al repositorio original del profesor y Git da error, ya que debo subirlos a mi propio
repositorio. Para ello hago uso del siguiente comando "git remote set-url origin https://github.com/luciaoropesa/p1.git", consiguendo cambiar 
a la url des mi propio repositorio. Así conseguiré cambiar la dirección. 
Para comprobarlo, hago uso del comando " git remote -v", que devuelve lo siguiente por pantalla: 
-----------Impreso por pantalla: 
origin  https://github.com/luciaoropesa/p1.git (fetch)
origin  https://github.com/luciaoropesa/p1.git (push)
-------------
Por tanto, ya está listo para poder hacer push a mi propio repositorio. 
Antes de nada, vuelvo a guardar el archivo con "add" y "commit" para enviar la nueva versión a la nube. Si no lo guardase, mandaría hasta la
última versión hecha con "commit". 

6. git checkout -b rama_prueba
Con este comando le estoy diciendo que cree una rama nueva y que se cambie a ella inmediatamente para poder trabajar desde ahí. 
Esto hace que la rama "main" quede con los cambios anteriores y para aplicar y probar nuevos cambios, puedo usar esta rama y después 
mandarlos a la principal. 
------Impreso en la terminal: 
Switched to a new branch 'rama_prueba'
-------------


Por tanto, ya tengo creada la rama de prueba. Para ir moviendome por las diferentes ramas, bastaría con poner "git checkout nombre_rama".
----Imrpimo por pantalla: 
M       git.txt
Switched to branch 'main'
Your branch is up to date with 'origin/main'.
---------------------
Por tanto, ya me habría cambiado de rama a la principal. 

Además, para dejar creada la rama y que sea accesible para cualquier persona que entre en mi enlace de GitHub, debo hacer un push ("git push origin rama_prueba"). 
----Imprimo por pantalla: 
Enumerating objects: 4, done.
Counting objects: 100% (4/4), done.
Delta compression using up to 2 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 417 bytes | 417.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)
remote: 
remote: Create a pull request for 'rama_prueba' on GitHub by visiting:
remote:      https://github.com/luciaoropesa/p1/pull/new/rama_prueba
remote: 
To https://github.com/luciaoropesa/p1.git
 * [new branch]      rama_prueba -> rama_prueba
 ---------------------------
Con esto ya me estaría asegurando que la rama es visible para todos los usuarios.



Para hacer unas pruebas y comprobar el funcionamiento de una nueva rama, voy a crear un archivo en la carpeta que voy a usar sólo para 
rama_nueva. Hago uso de "git add archivo_rama.txt" y " git commit -m "probando cambios en el archivo creado para la nueva rama" ". 
¿Qué pasa con esto? Las ramas son independientes. Esto quiere decir que el archivo .txt creado para la rama_prueba NO se ve desde la rama "main". 
Por tanto, cuando esté en rama_prueba podré ver en la carpeta p1 (desde la izquierda) que cuento con "archivo_rama.txt"; en cambio, si 
vuelvo a la rama "main", veo que no cuento con ese archivo. 

Por último, sólo queda volver a guardar los cambios realizados en este .txt y mandarlo a la nube, tal y como hemos ido aprendiendo durante la 
práctica. 





